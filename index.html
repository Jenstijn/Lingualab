<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>LinguaLab ‚Äî Stap 3: Analyse + Popups</title>
  <meta name="theme-color" content="#0b1021">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <link rel="apple-touch-icon" href="icons/icon-192.png">
  <style>
    :root {
      --bg: rgba(12,14,16, 1);
      --panel: rgba(255,255,255,0.08);
      --panel-strong: rgba(255,255,255,0.12);
      --text: #e8ecf1;
      --muted: #a8b0ba;
      --accent: #7dd3fc;
      --accent-2: #c3eaff;
      --shadow: 0 10px 30px rgba(0,0,0,0.25);
      --hairline: 1px solid rgba(255,255,255,0.14);
      --backdrop: blur(18px) saturate(130%);
      --radius: 18px;
      --radius-sm: 12px;
      --ok: #38d39f; --warn: #ffd166; --bad: #ff6b6b;
      --glass: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
      --blue:#60a5fa; --green:#34d399; --orange:#f59e0b; --purple:#a78bfa;
      --blueBg: rgba(96,165,250,0.22); --greenBg: rgba(52,211,153,0.22);
      --orangeBg: rgba(245,158,11,0.22); --purpleBg: rgba(167,139,250,0.22);
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f6f7fb; --panel: rgba(255,255,255,0.65); --panel-strong: rgba(255,255,255,0.8);
        --text: #0b1520; --muted: #536070; --accent: #007aff; --accent-2: #64b5ff;
        --shadow: 0 8px 20px rgba(0,0,0,0.12); --hairline: 1px solid rgba(0,0,0,0.08);
        --glass: linear-gradient(180deg, rgba(255,255,255,0.85), rgba(255,255,255,0.65));
        --blueBg: rgba(96,165,250,0.22); --greenBg: rgba(52,211,153,0.22);
        --orangeBg: rgba(245,158,11,0.22); --purpleBg: rgba(167,139,250,0.22);
      }
    }
    html, body { margin: 0; height: 100%; background: var(--bg); color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    header { position: sticky; top: 0; z-index: 10; backdrop-filter: var(--backdrop);
      background: linear-gradient(180deg, rgba(0,0,0,0.25), rgba(0,0,0,0.05)); border-bottom: var(--hairline);
      padding-top: env(safe-area-inset-top); }
    .wrap { max-width: 980px; margin: 0 auto; padding: 16px; }
    h1 { margin: 0; font-size: 22px; display:flex; align-items:center; gap:10px;}
    .spark { color: var(--accent); filter: drop-shadow(0 0 8px rgba(125,211,252,0.35)); }
    .subtitle { color: var(--muted); font-size: 13px; margin-top: 4px; }
    .grid { display: grid; grid-template-columns: 1.05fr .95fr; gap: 16px; margin-top: 16px; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
    .panel { background: var(--panel); border: var(--hairline); border-radius: var(--radius);
      box-shadow: var(--shadow); backdrop-filter: var(--backdrop); padding: 14px; animation: slideIn .45s ease both; }
    @keyframes slideIn { from { opacity: 0; transform: translateY(8px) scale(0.995);} to { opacity: 1; transform: translateY(0) scale(1);} }
    textarea, select, input {
      width: 100%; background: var(--panel-strong); border: var(--hairline); color: var(--text);
      border-radius: var(--radius-sm); padding: 12px 14px; font: inherit; font-size: 16px; outline: none;
    }
    textarea { min-height: 140px; resize: vertical; }
    .row { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .row > * { flex: 1; min-width: 160px; }
    .btn { cursor: pointer; padding: 12px 14px; border-radius: 14px; border: var(--hairline); background: var(--glass);
      min-height: 44px; font-weight: 600; transition: transform .05s ease; }
    .btn:active { transform: translateY(1px); }
    .btn.primary { border-color: rgba(125,211,252,0.7); box-shadow: 0 4px 18px rgba(125,211,252,0.18); }
    .small { font-size: 12px; color: var(--muted); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; white-space: pre-wrap; }
    .fadein { animation: slideIn .35s ease both; }
    .tags { line-height: 2.1; font-size: 17px; }
    .tag { padding: 2px 6px; border-radius: 8px; margin: 0 2px; display: inline-block; }
    .tag-subj { background: var(--blueBg); color: var(--text); border: 1px solid rgba(96,165,250,0.5); }
    .tag-verb { background: var(--greenBg); color: var(--text); border: 1px solid rgba(52,211,153,0.5); }
    .tag-clause { background: var(--orangeBg); color: var(--text); border: 1px solid rgba(245,158,11,0.5); }
    .tag-prep { background: var(--purpleBg); color: var(--text); border: 1px solid rgba(167,139,250,0.5); }
    /* Popup */
    .popover-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.25); backdrop-filter: blur(3px); display:none; }
    .popover { position: fixed; left: 50%; bottom: 12px; transform: translateX(-50%); max-width: 92vw;
      background: var(--panel); border: var(--hairline); border-radius: 16px; box-shadow: var(--shadow);
      padding: 12px; display:none; }
    .popover h3 { margin: 0 0 6px 0; font-size: 16px; }
    .muted { color: var(--muted); font-size: 12px; }
    .pair { background: var(--panel-strong); border: var(--hairline); border-radius: 10px; padding: 8px; margin-top: 8px; }
  </style>
</head>
<body>
  <header>
    <div class="wrap">
      <h1>LinguaLab <span class="spark">‚ö°</span><span class="small"> ‚Äî Analyse + Popups</span></h1>
      <div class="subtitle">Kleurmarkering ‚Ä¢ NL-uitleg ‚Ä¢ Dynamische voorbeeldzinnen</div>
    </div>
  </header>

  <main class="wrap">
    <div class="grid">
      <section class="panel">
        <h2 style="margin:6px 0 10px 0;">üó£Ô∏è Invoer</h2>
        <textarea id="input" placeholder="Typ of dicteer hier‚Ä¶"></textarea>
        <div class="row" style="margin-top:10px;">
          <select id="source">
            <option value="auto">Detecteer automatisch</option>
            <option value="nl">Nederlands</option>
            <option value="en">Engels</option>
            <option value="pt">Portugees (BR)</option>
          </select>
          <select id="target">
            <option value="pt">Portugees (BR)</option>
            <option value="nl">Nederlands</option>
            <option value="en">Engels</option>
          </select>
        </div>
        <div class="row" style="margin-top:10px;">
          <label class="small"><input type="checkbox" id="carioca" checked> Carioca/informeel PT-BR</label>
        </div>
        <div class="row" style="margin-top:10px;">
          <button class="btn primary" id="btnTranslate">‚ÜîÔ∏è Vertaal & Analyseer</button>
          <button class="btn" id="btnClear">üßπ Leeg</button>
        </div>
        <div class="small" id="status" style="margin-top:8px;"></div>
      </section>

      <section class="panel">
        <h2 style="margin:6px 0 10px 0;">üìò Output</h2>
        <div id="output" class="mono">Klaar voor input‚Ä¶</div>
        <div id="analysis" class="tags" style="margin-top:10px;"></div>
        <div id="notes" class="small" style="margin-top:8px;"></div>
      </section>
    </div>
  </main>

  <div class="popover-backdrop" id="popBackdrop"></div>
  <div class="popover" id="pop">
    <h3 id="popTitle">Uitleg</h3>
    <div id="popText" class="small"></div>
    <div class="pair">
      <div class="muted">Voorbeeld (NL)</div>
      <div id="popEgNl" class="mono"></div>
    </div>
    <div class="pair">
      <div class="muted">Voorbeeld (doeltaal)</div>
      <div id="popEgTgt" class="mono"></div>
    </div>
  </div>

  <script>
    // === Providers (fallback chain) ===
    const ENDPOINTS = [
      { name:'LibreTranslate .com', type:'libre', base:'https://libretranslate.com' },
      { name:'LibreTranslate .de', type:'libre', base:'https://libretranslate.de' },
      { name:'LibreTranslate astian', type:'libre', base:'https://translate.astian.org' },
      { name:'LibreTranslate fyed', type:'libre', base:'https://translate.fyed.xyz' },
      { name:'CORS proxy .com', type:'libre-proxy', base:'https://cors.isomorphic-git.org/https://libretranslate.com' },
      { name:'CORS proxy .de', type:'libre-proxy', base:'https://cors.isomorphic-git.org/https://libretranslate.de' },
      { name:'MyMemory', type:'mymemory', base:'https://api.mymemory.translated.net' }
    ];

    const statusEl = document.getElementById('status');
    const inputEl  = document.getElementById('input');
    const outEl    = document.getElementById('output');
    const analysisEl = document.getElementById('analysis');
    const notesEl = document.getElementById('notes');
    const sourceEl = document.getElementById('source');
    const targetEl = document.getElementById('target');
    const cariocaEl= document.getElementById('carioca');

    const slangRules = [
      {from:/\\bvoc√™ est√°\\b/gi, to:'c√™ t√°'},
      {from:/\\best√°\\b/gi, to:'t√°'},
      {from:/\\bvoc√™\\b/gi, to:'c√™'},
      {from:/\\bestou\\b/gi, to:'t√¥'},
      {from:/\\bpara o\\b/gi, to:'pro'},
      {from:/\\bpara a\\b/gi, to:'pra'}
    ];
    function applyCarioca(pt){ let out=pt; slangRules.forEach(r=>out=out.replace(r.from,r.to)); return out; }

    function langMapForMyMemory(code){
      if (code==='pt') return 'pt'; if (code==='nl') return 'nl'; if (code==='en') return 'en'; return 'en';
    }

    async function callJSON(url, body){
      const ctrl = new AbortController();
      const resP = fetch(url, {
        method: 'POST', headers: {'Content-Type':'application/json','Accept':'application/json'},
        body: JSON.stringify(body), signal: ctrl.signal, mode:'cors', credentials:'omit', referrerPolicy:'no-referrer'
      });
      const t = setTimeout(()=>ctrl.abort(), 12000);
      try {
        const res = await resP;
        if (!res.ok) throw new Error('HTTP '+res.status);
        const data = await res.json();
        if (data.error) throw new Error(data.error);
        return data;
      } finally { clearTimeout(t); }
    }

    async function detectLangAuto(q, base, type){
      if (type.startsWith('libre')) {
        try {
          const data = await callJSON(base + '/detect', { q });
          if (Array.isArray(data) && data.length) {
            const best = data.sort((a,b)=>(b.confidence||0)-(a.confidence||0))[0];
            return best.language || 'en';
          }
        } catch(e){}
      }
      const t = q.toLowerCase();
      if (/[√£√µ√ß√°√©√≠√≥√∫√¢√™√¥]/.test(t) || /voc√™|t√¥|t√°|cad√™|grana|a gente/.test(t)) return 'pt';
      if (/\b(het|de|een|ik|jij|wij|jullie|niet)\b/.test(t)) return 'nl';
      return 'en';
    }

    async function translateProvider(q, src, dst, provider){
      if (provider.type==='libre' || provider.type==='libre-proxy'){
        let source = src;
        if (source==='auto') source = await detectLangAuto(q, provider.base, provider.type);
        const data = await callJSON(provider.base + '/translate', { q, source, target: dst, format:'text' });
        return data.translatedText || data;
      } else if (provider.type==='mymemory'){
        let source = src;
        if (source==='auto') source = await detectLangAuto(q, provider.base, 'heuristic');
        const s = langMapForMyMemory(source);
        const t = langMapForMyMemory(dst);
        const url = provider.base + '/get?q=' + encodeURIComponent(q) + '&langpair=' + s + '|' + t;
        const res = await fetch(url, { mode:'cors', credentials:'omit', referrerPolicy:'no-referrer' });
        const data = await res.json();
        if (data?.responseStatus !== 200) throw new Error('MyMemory ' + (data?.responseStatus||'err'));
        return data?.responseData?.translatedText || '';
      }
      throw new Error('Unknown provider');
    }

    async function translateWithChain(q, src, dst){
      let lastErr = null;
      for (const p of ENDPOINTS){
        try {
          statusEl.textContent = 'Proberen via ' + p.name + '‚Ä¶';
          const text = await translateProvider(q, src, dst, p);
          return { text, provider: p.name };
        } catch (e) { lastErr = e; }
      }
      throw lastErr || new Error('Geen provider beschikbaar');
    }

    // === Grammar analysis (very light heuristics) on the TARGET sentence ===
    const pronouns = {
      nl: ['ik','jij','je','u','hij','zij','ze','wij','we','jullie','zij'],
      en: ['i','you','he','she','we','they'],
      pt: ['eu','voc√™','ele','ela','a','gente','n√≥s','voc√™s','eles','elas']
    };
    const preps = {
      nl: ['in','op','aan','met','voor','na','bij','naar','van','tot','onder','boven','tijdens','zonder','tegen','rond','door','over','uit'],
      en: ['in','on','at','to','for','from','with','by','about','over','under','between','without','during','against','through'],
      pt: ['em','no','na','num','numa','com','para','pra','pro','de','do','da','dos','das','por','sem','entre','sobre','at√©']
    };
    const clauseMarkers = {
      nl: ['dat','omdat','als','terwijl','wanneer','zodat','hoewel','die','waar','toen'],
      en: ['that','because','if','while','when','so that','although','who','which','where'],
      pt: ['que','porque','se','enquanto','quando','para que','embora','quem','onde']
    };
    const auxVerbs = {
      nl: ['ben','bent','is','zijn','was','waren','heb','hebt','heeft','hebben','had','hadden','zal','zullen','zou','zouden','ga','gaat','gaan','ging','gingen','doe','doet','doen'],
      en: ['am','is','are','was','were','be','been','being','have','has','had','do','does','did','will','would','can','could','should','must','may','might','go','goes','went'],
      pt: ['sou','√©','somos','s√£o','fui','foi','fomos','foram','era','√©ramos','eram','estou','est√°','estamos','est√£o','estava','estavam','tenho','tem','temos','t√™m','tinha','tivemos','vou','vai','vamos','v√£o','iria']
    };

    function guessTense(tokens, lang){
      const t = tokens.map(x=>x.toLowerCase());
      if (lang==='en'){
        if (t.includes('will')) return 'toekomende tijd (will + infinitief)';
        if (t.includes('am')||t.includes('is')||t.includes('are')){
          const hasIng = tokens.some(w=>/ing\\b/i.test(w));
          if (hasIng) return 'onvoltooid tegenwoordige tijd (continuous)';
        }
        if (t.includes('did')||t.includes('was')||t.includes('were')) return 'verleden tijd';
        if (t.includes('have')||t.includes('has')||t.includes('had')) return 'perfect (have/has + voltooid deelwoord)';
        return 'tegenwoordige tijd';
      }
      if (lang==='pt'){
        if (t.includes('vou')||t.includes('vai')||t.includes('vamos')||t.includes('v√£o')) return 'futuro perifr√°stico (ir + infinitivo)';
        if (t.some(w=>/(ei|ou|aram|eram|eu)\\b/.test(w))) return 'pret√©rito perfeito (verleden, afgerond)';
        if (t.some(w=>/(ava|ia|√≠amos|iam)\\b/.test(w))) return 'pret√©rito imperfeito (verleden, duur/gewoonte)';
        return 'presente';
      }
      if (lang==='nl'){
        if (t.includes('zal')||t.includes('zullen')||t.includes('zou')||t.includes('zouden')) return 'toekomende tijd (zullen)';
        if (t.includes('ben')||t.includes('bent')||t.includes('is')||t.includes('zijn')||t.includes('was')||t.includes('waren')){
          const hasGe = tokens.some(w=>/^ge.+/i.test(w));
          if (hasGe && (t.includes('heb')||t.includes('hebt')||t.includes('heeft')||t.includes('hebben')||t.includes('had')||t.includes('hadden')||t.includes('ben')||t.includes('is'))) return 'perfectum (heb/ben + ge-)';
          if (t.includes('was')||t.includes('waren')) return 'onvoltooid verleden (OVT)';
        }
        return 'tegenwoordige tijd';
      }
      return 'onbekende tijd';
    }

    function analyzeSentence(sentence, lang){
      const words = sentence.match(/\\w+|[^\\s\\w]/g) || [];
      const tags = [];
      const lower = words.map(w=>w.toLowerCase());

      // Subject: first matching pronoun
      const subjSet = new Set((pronouns[lang]||[]));
      for (let i=0;i<lower.length;i++){
        if (subjSet.has(lower[i])) { tags.push({i,type:'subj'}); break; }
      }

      // Verbs: auxiliary list + simple heuristics
      const aux = new Set(auxVerbs[lang]||[]);
      for (let i=0;i<lower.length;i++){
        const w = lower[i];
        if (aux.has(w) || /ar$|er$|ir$/i.test(w) && lang==='pt' || /ing$/i.test(w) && lang==='en' ) {
          tags.push({i,type:'verb'});
        }
        if (lang==='nl' && /^ge.+/i.test(w)) tags.push({i,type:'verb'});
        if (lang==='pt' && /(ei|ou|aram|ava|ia|√≠amos|iam)$/.test(w)) tags.push({i,type:'verb'});
      }

      // Clauses: mark the marker tokens
      const cm = new Set((clauseMarkers[lang]||[]));
      for (let i=0;i<lower.length;i++){
        if (cm.has(lower[i])) tags.push({i,type:'clause'});
      }

      // Prepositions
      const prepSet = new Set((preps[lang]||[]));
      for (let i=0;i<lower.length;i++){
        if (prepSet.has(lower[i])) tags.push({i,type:'prep'});
      }

      const tense = guessTense(words, lang);

      return { words, tags, tense };
    }

    function renderTags(container, analysis, lang){
      const { words, tags } = analysis;
      const map = new Map();
      tags.forEach(t=>{ if (!map.has(t.i)) map.set(t.i, []); map.get(t.i).push(t.type); });

      container.innerHTML = '';
      for (let i=0;i<words.length;i++){
        const tok = words[i];
        const types = map.get(i) || [];
        if (types.length){
          const span = document.createElement('span');
          span.textContent = tok;
          span.className = 'tag ' + types.map(t=>'tag-'+t).join(' ');
          span.dataset.types = types.join(',');
          span.dataset.token = tok;
          container.appendChild(span);
        } else {
          const t = document.createTextNode(tok);
          container.appendChild(t);
        }
        container.appendChild(document.createTextNode(' '));
      }
    }

    // Popover with NL + target example
    const pop = document.getElementById('pop');
    const popBg = document.getElementById('popBackdrop');
    const popTitle = document.getElementById('popTitle');
    const popText  = document.getElementById('popText');
    const popEgNl  = document.getElementById('popEgNl');
    const popEgTgt = document.getElementById('popEgTgt');
    function closePop(){ pop.style.display='none'; popBg.style.display='none'; }
    popBg.addEventListener('click', closePop);

    const eg = {
      subj: [
        'Ik werk morgen thuis.',
        'Jij leert snel.',
        'Hij heeft honger.',
        'Zij komt later.',
        'Wij gaan naar het strand.',
        'Jullie moeten dit zien.',
        'Zij wonen in Rio.'
      ],
      verb: [
        'We hebben het al gedaan.',
        'Ik ga straks koken.',
        'Hij liep gisteren naar huis.',
        'Zij zal het morgen uitleggen.',
        'We zijn te laat vertrokken.'
      ],
      clause: [
        'Ik blijf thuis omdat het regent.',
        'Als ik tijd heb, bel ik je.',
        'Wanneer je klaar bent, gaan we.',
        'Hoewel ik moe ben, ga ik mee.',
        'Hij zei dat hij geen tijd had.'
      ],
      prep: [
        'Ik wacht op de bus.',
        'We gaan naar huis.',
        'Ze zit in de trein.',
        'Hij woont bij zijn ouders.',
        'We praten over het plan.',
        'Ik kom uit Nederland.',
        'Het boek ligt op tafel.'
      ]
    };

    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    async function openPop(types){
      const type = types.split(',')[0];
      const tgt = targetEl.value;
      popTitle.textContent = ({subj:'Onderwerp',verb:'Werkwoord',clause:'Bijzin',prep:'Voorzetsel'})[type] || 'Uitleg';
      popText.textContent = ({
        subj: 'Het onderwerp is wie/wat de handeling uitvoert. In NL staat het meestal voor het persoonsvorm.',
        verb: 'Het werkwoord geeft de handeling/tijd aan. Let op hulpwerkwoorden en verbuigingen.',
        clause: 'Een bijzin heeft vaak een marker zoals ‚Äúdat‚Äù, ‚Äúomdat‚Äù, ‚Äúals‚Äù.',
        prep: 'Voorzetsels verbinden woorden met plaats/tijd/richting (bijv. ‚Äúin‚Äù, ‚Äúop‚Äù, ‚Äúnaar‚Äù).'
      })[type] || '';

      const egNl = pick(eg[type]||['Voorbeeldzin niet beschikbaar.']);
      popEgNl.textContent = egNl;
      popEgTgt.textContent = 'Vertalen‚Ä¶';
      pop.style.display='block'; popBg.style.display='block';

      try {
        const { text } = await translateWithChain(egNl, 'nl', tgt);
        popEgTgt.textContent = text;
      } catch {
        popEgTgt.textContent = '(Kon voorbeeld niet vertalen)';
      }
    }

    analysisEl.addEventListener('click', (e)=>{
      const target = e.target;
      if (target.classList.contains('tag')) {
        openPop(target.dataset.types);
      }
    });

    // === Main button ===
    document.getElementById('btnTranslate').addEventListener('click', async () => {
      const text = inputEl.value.trim();
      if (!text) { alert('Voer eerst een zin in.'); return; }
      const src = sourceEl.value; const dst = targetEl.value;

      statusEl.textContent = navigator.onLine ? 'Vertalen‚Ä¶' : 'Je bent offline ‚Äî vertalen kan mislukken.';
      outEl.textContent = ''; analysisEl.textContent=''; notesEl.textContent='';

      try {
        let { text: translated } = await translateWithChain(text, src, dst);
        if (dst === 'pt' && cariocaEl.checked) translated = applyCarioca(translated);
        outEl.textContent = `‚ñ∂ Vertaling (${dst}):\n` + translated;

        // Analyze the TARGET sentence
        const analysis = analyzeSentence(translated, dst);
        renderTags(analysisEl, analysis, dst);

        const bullets = [];
        if (analysis.tense) bullets.push('‚è±Ô∏è Tijd: ' + analysis.tense);
        if (dst==='pt' && cariocaEl.checked) bullets.push('üéß Slang-modus: para‚Üípra/pro, voc√™ est√°‚Üíc√™ t√°, estou‚Üít√¥.');
        notesEl.textContent = bullets.join(' ‚Ä¢ ') || 'Geen speciale opmerkingen.';

        statusEl.textContent = 'Klaar.';
      } catch (err) {
        statusEl.innerHTML = '<span class="bad">Kon niet vertalen.</span>';
        outEl.textContent = 'Fout: ' + (err?.message || 'onbekend') + '\\nProbeer later nog eens.';
      }
    });

    document.getElementById('btnClear').addEventListener('click', () => {
      inputEl.value=''; outEl.textContent='Klaar voor input‚Ä¶'; analysisEl.textContent=''; notesEl.textContent=''; statusEl.textContent='';
    });

    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('./sw.js').catch(()=>{});
    }
  </script>
</body>
</html>
